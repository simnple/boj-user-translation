<section id="title">트리플 제거</section>
<section id="description">
  <div class="headline">
    <h2>문제</h2>
  </div>
  <div id="problem_description" class="problem-text">
    <p>
      원딜을 서포트하는 것에 지친 케리아는 구간 연산을 지원하는 자료구조 문제를
      만들기로 했다.
    </p>

    <p>
      $0$과 $1$로만 이루어져 있는 길이 $m$의 배열 $b = [b_1, b_2, \ldots,
      b_m]$에 대해 <strong>트리플 제거</strong> 연산을 아래와 같이 정의한다.
    </p>

    <ol>
      <li>$b_i = b_j = b_k$를 만족하는 인덱스 $i$, $j$, $k$를 고른다.</li>

      <li>
        고른 세 인덱스에 대응하는 세 원소 $b_i$, $b_j$, $b_k$를 배열에서
        제거한다. 이 때 $\mathrm{min}(k - j, j - i)$만큼의 비용이 든다. 배열에
        남은 값들은 연결되며, 이에 따라 인덱스의 번호도 재조정된다.
      </li>
    </ol>

    <p>
      당신은 <strong>트리플 제거</strong> 연산을 원하는 만큼 사용하여 배열 $b$를
      비우고 싶다. 배열의 <em>총 비용</em>을 배열을 비우는 데 필요한
      <strong>트리플 제거</strong>
      연산의 비용의 합의 최솟값이라 하자. 배열을 비우는 것이 불가능할 경우,
      <em>총 비용</em>은 $-1$로 정의한다.
    </p>

    <p>
      케리아는 자신의 자료구조를 테스트하고 싶어졌다. 이를 위해, 당신은 $q$개의
      독립적인 쿼리에 답해야 한다. 맨 처음, 당신에게 $0$과 $1$로만 이루어져 있는
      길이 $n$의 배열 $a = [a_1, a_2, \cdots, a_n]$가 주어진다. 각 쿼리에서는
      구간 $[l, r]$이 주어진다. 이 때 $1 \le l \le r \le n$를 만족한다. 이 때,
      당신은 배열 $[a_l, a_{l+1}, \cdots, a_r]$을 비우는 데에 드는
      <em>총 비용</em>을 구해야 한다.
    </p>
  </div>
</section>
<section id="input">
  <div class="headline">
    <h2>입력</h2>
  </div>
  <div id="problem_input" class="problem-text">
    <p>
      입력은 여러 개의 테스트 케이스로 이루어져 있다. 첫째 줄에 테스트 케이스의
      수 $t$ ($1 \le t \le 10^4)$가 주어진다. 이후 $t$개의 테스트 케이스가
      주어진다.
    </p>

    <p>
      각 테스트 케이스의 첫째 줄에는 정수 $n$, $q$ ($1 \le n, q \le 250\,000$)가
      공백으로 구분되어 주어진다.
    </p>

    <p>
      그 다음 줄에는 $a_1, a_2, \cdots, a_n$ ($a_i= 0$ 또는 $a_i = 1$)가
      공백으로 구분되어 차례대로 주어진다.
    </p>

    <p>
      그 다음 $q$줄에 걸쳐 쿼리가 한 줄에 하나씩 주어진다. $i$번째 쿼리에서는
      구간을 의미하는 $l_i$, $r_i$ ($1 \le l_i \le r_i \le n$)가 공백으로
      구분되어 주어진다.
    </p>

    <p>
      모든 테스트 케이스에서 주어지는 $n$의 합과 $q$의 합은 각각 $250\,000$을
      넘지 않는다.
    </p>
  </div>
</section>
<section id="output">
  <div class="headline">
    <h2>출력</h2>
  </div>
  <div id="problem_output" class="problem-text">
    <p>
      총 $q$줄의 답을 출력해야 한다. $i$번째 줄에는 $i$번째 쿼리에 대응하는 답을
      출력한다.
    </p>
  </div>
</section>
<section id="hint">
  <div class="headline">
    <h2>노트</h2>
  </div>
  <div id="problem_hint" class="problem-text">
    <p>
      <strong
        >아래는 첫 번째 테스트 케이스의 첫 번째 쿼리인 $(1\;12)$에 대한
        설명이다.</strong
      >
    </p>

    <p>
      구간에 대응하는 배열은 $[0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0]$이다.
      배열에는 $0$과 $1$이 각각 $6$회씩 등장한다. 최적의 방법으로 연산들을
      적용하는 방법은 아래와 같다.
    </p>

    <ol>
      <li>
        인덱스 $3$, $4$, $6$에 있는 값이 $1$인 세 원소를 배열에서 제거한다.
        비용은 $\min(6-4, 4-3) = \min(2, 1) = 1$이다. 배열은 $[0, 0, 0, 0, 1, 0,
        1, 1, 0]$가 된다.
      </li>

      <li>
        인덱스 $1$, $2$, $3$에 있는 값이 $0$인 세 원소를 배열에서 제거한다.
        비용은 $\min(3-2, 2-1) = \min(1, 1) = 1$이다. 배열은 $[0, 1, 0, 1, 1,
        0]$가 된다.
      </li>

      <li>
        인덱스 $2$, $4$, $5$에 있는 값이 $1$인 세 원소를 배열에서 제거한다.
        비용은 $\min(5-4, 4-2) = \min(1, 2) = 1$이다. 배열은 $[0, 0, 0]$가 된다.
      </li>

      <li>
        인덱스 $1$, $2$, $3$에 있는 값이 $0$인 세 원소를 배열에서 제거한다.
        비용은 $\min(3-2, 2-1) = \min(1, 1) = 1$이다. 이 연산으로 배열을 비웠다.
      </li>
    </ol>

    <p>총 비용은 $1 + 1 + 1 + 1 = 4$다.</p>
  </div>
</section>
